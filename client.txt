import socket
import RPi.GPIO as GPIO
import smbus
import time
import threading

# ì„œë²„ ì„¤ì •
SERVER_IP = '10.125.126.208'
EVENT_PORT = 9000       # ì´ë²¤íŠ¸ìš© í¬íŠ¸
JOYSTICK_PORT = 5000    # ì¡°ì´ìŠ¤í‹±ìš© í¬íŠ¸

# ì¡°ì´ìŠ¤í‹± ì„¤ì • (I2C)
address = 0x48
A0 = 0x40  # Up/Down
A1 = 0x41  # Left/Right
bus = smbus.SMBus(1)

# GPIO í•€ ì„¤ì •
SHOCK_PIN = 17
BUTTON_PIN = 18
LIGHT_PIN = 27

# ì†Œì¼“ ì—°ê²°
event_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
joystick_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
    event_client.connect((SERVER_IP, EVENT_PORT))
    print("âœ… Connected to EVENT server.")
    joystick_client.connect((SERVER_IP, JOYSTICK_PORT))
    print("âœ… Connected to JOYSTICK server.")
except Exception as e:
    print("âŒ Connection failed:", e)
    exit()

# GPIO ì„¤ì •
GPIO.setmode(GPIO.BCM)
GPIO.setup(SHOCK_PIN, GPIO.IN)
GPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(LIGHT_PIN, GPIO.IN)

# ì´ì „ ìƒíƒœ ì €ì¥
shock_previous = GPIO.input(SHOCK_PIN)
button_previous = GPIO.input(BUTTON_PIN)
light_previous = GPIO.input(LIGHT_PIN)

# ì´ë²¤íŠ¸ í
event_queue = []
#queue_lock = threading.Lock() # í ë³´í˜¸ë¥¼ ìœ„í•œ ë½
# ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜
def send_event(message):
    try:
        event_client.sendall(message.encode('utf-8'))
    except Exception as e:
        print(f"âš ï¸ Error sending event: {e}")

def send_joystick(message):
    try:
        joystick_client.sendall(message.encode('utf-8'))
    except Exception as e:
        print(f"âš ï¸ Error sending joystick: {e}")

# ì´ë²¤íŠ¸ ì½œë°± í•¨ìˆ˜ë“¤
def shock_detected(channel):
    global shock_previous
    current_state = GPIO.input(SHOCK_PIN)
    if current_state != shock_previous:
        shock_previous = current_state
        print("ğŸš¨ Shock detected")
        # with queue_lock: # ë½ì„ íšë“í•˜ê³  íì— ì¶”ê°€
        event_queue.append("shock")

def button_pressed(channel):
    global button_previous
    current_state = GPIO.input(BUTTON_PIN)
    if current_state != button_previous:
        button_previous = current_state
        print("ğŸ”˜ Button pressed")
        # with queue_lock: # ë½ì„ íšë“í•˜ê³  íì— ì¶”ê°€
        event_queue.append("button")

def light_detected(channel):
    global light_previous
    current_state = GPIO.input(LIGHT_PIN)
    if current_state != light_previous:
        light_previous = current_state
        if current_state == GPIO.HIGH:
            print("ğŸŒ‘ Dark detected")
            # with queue_lock: # ë½ì„ íšë“í•˜ê³  íì— ì¶”ê°€
            event_queue.append("light")

# ì´ë²¤íŠ¸ ê°ì§€ ë“±ë¡
GPIO.add_event_detect(SHOCK_PIN, GPIO.FALLING, callback=shock_detected, bouncetime=200)
GPIO.add_event_detect(BUTTON_PIN, GPIO.FALLING, callback=button_pressed, bouncetime=200)
GPIO.add_event_detect(LIGHT_PIN, GPIO.RISING, callback=light_detected, bouncetime=200)

# ì´ë²¤íŠ¸ ì²˜ë¦¬ ìŠ¤ë ˆë“œ
def process_events():
    while True:
        if event_queue:
            message = event_queue.pop(0)
            send_event(message)
        time.sleep(0.05)
"""def process_events():
    while True:
        message_to_send = None
        with queue_lock: # ë½ì„ íšë“í•˜ê³  íì—ì„œ êº¼ëƒ„
            if event_queue:
                message_to_send = event_queue.pop(0)
        if message_to_send:
            send_event(message_to_send)
        time.sleep(0.05) # íê°€ ë¹„ì–´ìˆì–´ë„ ë„ˆë¬´ ë°”ì˜ê²Œ ëŒì§€ ì•Šë„ë¡"""

# ì¡°ì´ìŠ¤í‹± ë°ì´í„° ì „ì†¡ ìŠ¤ë ˆë“œ
def joystick_loop():
    while True:
        try:
            bus.write_byte(address, A0)
            time.sleep(0.01)
            value1 = bus.read_byte(address)

            bus.write_byte(address, A1)
            time.sleep(0.01)
            value2 = bus.read_byte(address)

            message = f"{value1},{value2}"
            send_joystick(message)
            print("ğŸ® Joystick:", message)

        except Exception as e:
            print("âš ï¸ Joystick read error:", e)

        time.sleep(0.1)

# ìŠ¤ë ˆë“œ ì‹œì‘
event_thread = threading.Thread(target=process_events, daemon=True)
joystick_thread = threading.Thread(target=joystick_loop, daemon=True)
event_thread.start()
joystick_thread.start()

# ë©”ì¸ ë£¨í”„
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("ğŸ›‘ Exiting...")
finally:
    GPIO.cleanup()
    event_client.close()
    joystick_client.close()
